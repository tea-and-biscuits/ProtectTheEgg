package uk.co.harieo.quackbedwars.shops.config;

import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import uk.co.harieo.quackbedwars.ProtectTheEgg;
import uk.co.harieo.quackbedwars.config.GameConfig;
import uk.co.harieo.quackbedwars.shops.ShopMenu;
import uk.co.harieo.quackbedwars.shops.ShopType;

public class ItemsConfig {

	private List<ShopCategory> categories;

	/**
	 * A handler for the items.yml configuration file which parses all the stated categories of items, adding them
	 * to their respective handlers, primarily {@link ShopCategory} and {@link ShopItem}, as they become available
	 *
	 * @param plugin which the configuration file belongs to
	 */
	public ItemsConfig(JavaPlugin plugin) {
		try {
			FileConfiguration config = GameConfig.getConfiguration(plugin, "items.yml");
			categories = ShopCategory.parseCategories(config);

			int amountOfCategories = categories.size();
			ShopMenu categoryMenu = new ShopMenu(ShopType.ITEMS, amountOfCategories / 9 + 1);
			for (int i = 0; i < amountOfCategories; i++) {
				ShopCategory category = categories.get(i);
				category.updateMenu(ShopType.ITEMS);
				categoryMenu.setStaticItem(i, category);
			}

			ShopType.ITEMS.setMenu(categoryMenu);
		} catch (IOException e) {
			e.printStackTrace();
			categories = Collections.emptyList(); // Prevents unnecessary null
		}
	}

	/**
	 * @return a list of all parsed categories in the order they were listed in the configuration file
	 */
	public List<ShopCategory> getCategories() {
		return categories;
	}

	/**
	 * Parses a {@link ConfigurationSection} for the data to form an {@link ItemStack} and uses strict error handling
	 * on the assumption that this configuration is generated by a human.
	 *
	 * This method searches for these keys in the section:
	 * name - The item name (required)
	 * material - The material name found with {@link Material#matchMaterial(String)} (required)
	 * amount - The amount in the stack (optional)
	 * lore - The list of strings to add to an item lore (optional)
	 *
	 * @param section to parse
	 * @return the parsed ItemStack or null if there was an error
	 */
	public static ItemStack parseItem(ConfigurationSection section) {
		Logger logger = ProtectTheEgg.getInstance().getLogger();
		String sectionName = section.getName();

		String name = section.getString("name");
		String materialName = section.getString("material");
		if (name != null) {
			if (materialName != null) {
				Material material = Material.matchMaterial(materialName);
				if (material != null) {
					ItemStack item = new ItemStack(material);
					if (section.contains("amount")) {
						item.setAmount(section.getInt("amount"));
					}

					ItemMeta meta = item.getItemMeta();
					if (meta != null) {
						meta.setDisplayName(ChatColor.translateAlternateColorCodes('&', name));
						if (section.contains("lore")) {
							List<String> lore = section.getStringList("lore");
							meta.setLore(lore
									.stream()
									.map(line -> ChatColor.translateAlternateColorCodes('&', line))
									.collect(Collectors.toList()));
						}
						item.setItemMeta(meta);
					}

					return item;
				} else {
					logger.warning("Section in item.yml has an invalid material: " + sectionName + ", " + materialName);
				}
			} else {
				logger.warning("Section in item.yml has no material: " + sectionName);
			}
		} else {
			logger.warning("Section in item.yml doesn't have a valid name: " + sectionName);
		}

		return null;
	}

}
